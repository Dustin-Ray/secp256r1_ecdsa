package main

import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/sha256"
	"math/big"
)

func main() {

	for i := 0; i < 100; i++ {
		rnd := rand.Reader
		data := make([]byte, 5242880) //5mb random data
		rnd.Read(data)
		key, r, s := sign_message_ecdsa(&data)
		res := verify_ecdsa_sig(key, r, s, &data)
		println(res)
	}
}

/*
Signing a message:

1. calculate e = HASH(M) <- here we use sha256
2. Let Z be L_n leftmost bits of e, where L_n is bit length of if group order n <- 256 bits for secp256k1
3. select cryptographically secure random integer k from [1, n-1]
4. get curve point (x1, y1) = k X G
5. Calculate r = x_1 mod n, if r = 0, go to step 3
6. calculate s = k^-1(z + rdA) mod n if S = 0, go to step 3
7. sig is pair (r, s)
*/
func sign_message_ecdsa(msg *[]byte) (*ecdsa.PublicKey, *big.Int, *big.Int) {

	secp256r1 := elliptic.P256() // aka secp256r1
	n := secp256r1.Params().Params().N

	g := ecdsa.PublicKey{
		Curve: secp256r1,
		X:     secp256r1.Params().Gx,
		Y:     secp256r1.Params().Gy,
	}

	// the secret key generated by the user
	rnd := rand.Reader
	d_a_bytes := make([]byte, 32)
	rnd.Read(d_a_bytes)
	pub_x, pub_y := g.ScalarBaseMult(d_a_bytes)
	Q_a := ecdsa.PublicKey{
		Curve: elliptic.P256(),
		X:     pub_x,
		Y:     pub_y,
	}
	d_a := big.NewInt(0).SetBytes(d_a_bytes)

	e := sha256.Sum256(*msg)
	z := big.NewInt(0).SetBytes(e[:32])

	k_read := rand.Reader // if fails its bc this is gen new rand every time
	k_bytes := make([]byte, 32)
	k_read.Read(k_bytes)
	k := big.NewInt(0).SetBytes(k_bytes)
	k = k.Mod(k, n)

	x1, _ := g.ScalarBaseMult(k_bytes)
	r := big.NewInt(0).Mod(x1, n)
	k_inv := big.NewInt(0).ModInverse(k, n)

	// calculate s = k^-1 (z+r*d_a) mod n
	s := big.NewInt(0).Mul(k_inv, big.NewInt(0).Add(z, big.NewInt(0).Mul(r, d_a)))
	s = big.NewInt(0).Mod(s, n)

	return &Q_a, r, s

}

func verify_ecdsa_sig(Q_a *ecdsa.PublicKey, r, s *big.Int, msg *[]byte) bool {

	secp256r1 := elliptic.P256() // aka secp256r1
	n := secp256r1.Params().Params().N

	g := ecdsa.PublicKey{
		Curve: secp256r1,
		X:     secp256r1.Params().Gx,
		Y:     secp256r1.Params().Gy,
	}

	e := sha256.Sum256(*msg)
	z := big.NewInt(0).SetBytes(e[:32])
	s_inv := big.NewInt(0).ModInverse(s, n)

	zs_inv := big.NewInt(0).Mul(z, s_inv)
	u1 := big.NewInt(0).Mod(zs_inv, n)
	u2 := big.NewInt(0).Mul(r, s_inv)
	u2 = big.NewInt(0).Mod(u2, n)

	x1, y1 := g.ScalarBaseMult(u1.Bytes())
	x2, y2 := g.ScalarMult(Q_a.X, Q_a.Y, u2.Bytes())
	res_x, _ := g.Add(x1, y1, x2, y2)

	return res_x.Cmp(r) == 0
}
