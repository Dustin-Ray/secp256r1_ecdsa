package main

import (
	"crypto/rand"
	"fmt"
	"math/big"
	"time"

	"golang.org/x/crypto/sha3"
)

func run_e222_schnorr() {

	total := 0
	loops := 100
	rnd := rand.Reader
	data := make([]byte, 5242880)
	rnd.Read(data)
	for i := 0; i < loops; i++ {
		start := time.Now()
		key, sig, e := sign_message_e222(&data)
		verify_sig_e222(key, sig, e, &data)
		elapsed := time.Since(start)
		// fmt.Println(res)
		total += int(elapsed.Microseconds())
	}
	fmt.Println("avg Î¼s to sign and verify e222: ", total/loops)
}

func sign_message_e222(msg *[]byte) (*E222, *big.Int, *big.Int) {

	g := E222GenPoint()
	n := g.n

	// the secret key generated by the user
	rnd := rand.Reader
	x_bytes := make([]byte, 32)
	rnd.Read(x_bytes)
	x := big.NewInt(0).SetBytes(x_bytes)
	y := g.SecMul(x)

	// random k from allowed set [1..n-1]
	k_read := rand.Reader
	k_bytes := make([]byte, 32)
	k_read.Read(k_bytes)
	k := big.NewInt(0).SetBytes(k_bytes)
	k.Add(k, big.NewInt(1))
	k = k.Mod(k, &n)

	r := g.SecMul(k)
	hash := sha3.New256()
	e_hash := hash.Sum([]byte(append(r.x.Bytes(), *msg...)))

	e := big.NewInt(0).SetBytes(e_hash[:32])
	xe := big.NewInt(0).Mul(x, e)

	s := k.Sub(k, xe)
	s = s.Mod(s, &n)
	return y, s, e
}

/*
let r_v = g^s * y^e
let e_v Hash(r_v || M)

return true iff e_v = e
*/
func verify_sig_e222(y *E222, s, e *big.Int, msg *[]byte) bool {
	g := E222GenPoint()

	gs := g.SecMul(s)
	gy := y.SecMul(e)

	r := gs.Add(gy)

	hash := sha3.New256()
	e_v := hash.Sum([]byte(append(r.x.Bytes(), *msg...)))
	return Equal(e_v[:32], e.Bytes())
}
